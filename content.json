[{"title":"数字无题","slug":"诗词_用FFFFFF填充的土地","date":"2021-01-19T16:06:50.000Z","updated":"2022-01-16T01:31:58.332Z","comments":true,"path":"2021/01/20/诗词_用FFFFFF填充的土地/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2021/01/20/%E8%AF%97%E8%AF%8D_%E7%94%A8FFFFFF%E5%A1%AB%E5%85%85%E7%9A%84%E5%9C%9F%E5%9C%B0/","excerpt":"","text":"用#FFFFFF填充的土地夹杂所有令别人兴奋的ARGB玷染我目光 心脏在夜里冷静而固执地跳动血液往复撞击管道尽头让每一百毫升的身体都有八十毫克凌驾于宇宙之外 它们看我整个的轮廓骨骼堆砌的山丘泪水从中穿行却汇聚不了河流 痕迹被岁月逐一像素中和除了这座身体的主人无人可复原它的早先模样 他自私着苦痛它自由地流淌打湿双眼的除了雨水别无他物醉倒的是身体而非我灵魂","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"deque深度探索","slug":"文章_deque","date":"2020-04-30T07:47:48.000Z","updated":"2022-01-16T01:29:29.971Z","comments":true,"path":"2020/04/30/文章_deque/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/04/30/%E6%96%87%E7%AB%A0_deque/","excerpt":"deque 是一种双向开口容器，不同于 stack 与 queue ，数据均可由它的两端进出。 STL 中的 deque 在 STL 中， deque 的具体实现为下图所示： 如上所示， deque 容器是由一个个 buffer 所构成，并且由一条顺序容器buf_map(vector)将其 buffer 串联起来用以记录 buffer 的地址和数量，最后加由 deque iterator 以构成连续空间的假象——","text":"deque 是一种双向开口容器，不同于 stack 与 queue ，数据均可由它的两端进出。 STL 中的 deque 在 STL 中， deque 的具体实现为下图所示： 如上所示， deque 容器是由一个个 buffer 所构成，并且由一条顺序容器buf_map(vector)将其 buffer 串联起来用以记录 buffer 的地址和数量，最后加由 deque iterator 以构成连续空间的假象——- deque - buffer - buf_map - iterator其中 buffer 就是一段连续内存，buf_map 将决定 buffer 们在 deque 中的先后顺序。##### deque 中的 buffer buffer 是一组固定大小的序列，其中存放着 deque 应该储存的数据； 每一个 buffer 的长度由所存数据的大小决定—— 在 GNUC 编译器中，一个 buffer 的长度是： 12template &lt;typename T&gt;buffer_size = sizeof(T) &gt; 512 ? 1 : 512 / sizeof(T); 当所存数据的大小超过 512 字节时，仅将一个 buffer 的长度设置为 1，否则将其设为 512/sizeof(T) ,例如当 deque 容器所储存数据类型为 int(sizeof=4) 时，那么一个 buffer 应当存放 128 个数据。 deque 中的 buf_map buf_map 是用于记录上述 buffer 所在位置的表，具体实现为 vertor ； 此 vector 中的每一个每一个值都储存着一个指针，用以指向每一个 buffer 的起点。 该 buf_map 中第一个指针指向 deque 中元素所占据第一个 buffer 的首位值。buf_map 中指针指向的地址是与 deque 所存储数据的空间无关的，buf_map 主要也是唯一的作用仅是用以记录组成 deque 容器中的 buffer。 因而 buf_map 中所存储的指针数目即为 deque 容器中 buffer 的个数(map_size)。 当使用者将数据不断存储到 deque 的过程中，若某一 buffer 即将不能满足储存要求(存满了)， deque 将会开辟出一块新的内存空间作为新 buffer 并将其地址储存为 buf_map 的新元素。 需要注意的是，当 buf_map 也无法满足存储要求(其内部空间已经存满了指向 buffer 的指针)，buf_map 将像正常的 vector 一样进行动态扩容，增长为其原内存的两倍(GNUC)大小；不过，在 vector 成功新开内存将原存储内容移动至新内存的过程中，buf_map 会将原内容尽可能的存贮在新内存的中间位置，以确保在后续 deque 的数据存储过程中两端均有足够的空间用以增长。 deque 中的 iterator 因 deque 是由一个个 buffer 和 buf_map 所拼凑出来的 “连续空间”，所以 deque iterator 的设计显得尤为重要！ 如上图所示，一个 deque iterator 由四部分组成： deque iterator cur[T*] first[T*] last[T*] node[T**] 其中 cur、first 和 last 均为指向所存储数据类型的指针，分别指向—— cur：当前 iterator 所指元素的位置 first：当前 iterator 所指元素 所在 buffer 的起始位置 last：当前 iterator 所指元素 所在 buffer 的末尾位置 而 node 是 指向该 iterator 所指元素所在的 buffer 在 buf_map 中存储的位置； 因 buf_map 储存的是指向一个 buffer 的指针(T**),所以 **node 的类型应为 pointer to (pointer to T)*(T)。 在本文章的首图中，以 deque 的两个特殊 iterator(start &amp; finish) 为例子： start 中 cur 指向 deque 容器第一个元素；first 指向 deque 容器中第一个 buffer的开始 ，这也是 buf_map 中存储的第一根指针指向的位置；end 指向 deque 容器中第一个 buffer 的结束；node 指向 buf_map[0]。 finish 中 cur 指向 deque 容器最后一个元素的下一个元素的位置(deque.end())，首图恰好展示了一个特殊情况—— deque 中的数据恰好占据完一整个 buffer，因此 deque 重新开辟出一块 buffer，所以自然 first 指向这个新 buffer ；end 指向此 buffer 的结束；node 指向 buf_map[buf_map.size()-1]。 deque iterator 中的运算符重载为了模拟连续空间， deque iterator 针对寻常指针可操作的部分运算符进行了重载以支持相关操作： 以下代码皆为简化版本，仅表达内部逻辑，实际操作中应遵循设计规则，参数类型等可能需要调整 operator++ 12345678910template &lt;typename T&gt;deque&lt;T&gt;::iterator operator++()&#123; ++node; //将 iterator 中指向元素的指针移动至下一个 if(cur==last)&#123; //如果此时移动至了此 buffer 的末尾 ++node; //将指向 buf_map 某位置的指针移动至下一个以定位到下一个 buffer cur = first = *node; //将新 buffer 的首元素地址赋值给 cur 和 first last = first+buf_size; //将 last 指针设置为新 buffer 的结尾(first+一个buffer容纳的数量) &#125; return *this;&#125; operator+= 123456789101112131415template &lt;typename T&gt;deque&lt;T&gt;::iterator operator+=(int n)&#123; int skip_num = n + (cur-first); //加上该元素当前所在buffer之前的所有数量 if(skip_num&gt;=0 &amp;&amp; skip_num&lt;buf_size)&#123; //此时若加上 n 是否还在本 buffer 内(考虑n为负数) cur +=n ; &#125;else&#123; int buf_skip_num = skip_num&gt;0 ? skip_snum/buf_size //若n为正数,该+=操作应跳跃的buffer数目 : -((skip_num/buf_size)+1); //若n为负数,该+=操作应跳跃的buffer数目 node += buf_skip_num; //将指向 buf_map 某位置的指针移动至下一个以定位到+=操作后iterator应指向位置所在的 buffer first = node; //重设first last = first+buf_size; //重设last cur = first + (skip_num - buf_skip_num*buf_size ); //将所cur指针移动至+=操作后在该buffer内应指向的位置 &#125; return *this;&#125; operator- 1234567template &lt;typename T&gt;int operator-(deque&lt;T&gt;::iterator n)&#123; //(node - n.node - 1)为两iterator之间间隔的buffer数目 //(cur - first)为当前iterator所指元素到所处buffer结尾的元素数目 //(n.last - n.cur)为减号后iterator所指元素到所处buffer起始的元素数目 return buf_size * (node - n.node - 1) + (cur - first) + (n.last - n.cur);&#125; operator* 1234template &lt;typename T&gt;T&amp; operator*()&#123; return *cur;&#125;","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/STL/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"list深度探索","slug":"文章_list","date":"2020-04-29T08:55:22.000Z","updated":"2022-01-16T01:29:51.995Z","comments":true,"path":"2020/04/29/文章_list/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/04/29/%E6%96%87%E7%AB%A0_list/","excerpt":"list 和 vector 一样，也是一种线性数据结构，不同于 vector 的是， list 所占用的内存空间并不是连续的，但它通过各种手段制造出一种连续内存空间的假象； list 因其内部结构的某些特点，在动态操作上能够消耗及其短暂的时间。 list 是由什么构成的？通常来说，一个 list 类仅需存放一根指向 list node 的指针；表示 list 节点的 list node 中才为应储存的内容。 list list node* —— 指向列表节点的指针 prev[ list node* ]* —— 指向列表中上一个元素位置的指针 next[ list node* ]* —— 指向列表中下一个元素位置的指针 data[ T ] —— 列表中存放的数据","text":"list 和 vector 一样，也是一种线性数据结构，不同于 vector 的是， list 所占用的内存空间并不是连续的，但它通过各种手段制造出一种连续内存空间的假象； list 因其内部结构的某些特点，在动态操作上能够消耗及其短暂的时间。 list 是由什么构成的？通常来说，一个 list 类仅需存放一根指向 list node 的指针；表示 list 节点的 list node 中才为应储存的内容。 list list node* —— 指向列表节点的指针 prev[ list node* ]* —— 指向列表中上一个元素位置的指针 next[ list node* ]* —— 指向列表中下一个元素位置的指针 data[ T ] —— 列表中存放的数据 STL 中的 list 如上图所示，在 STL 中， list 所呈现的内部结构为 双向环状列表 ； 并且，此 list 首节点的 prev 指针与末节点的 next 指针均指向一个并不存在于 list 容器内部的节点，从而形成环状。 list 容器的 iterator因 list 内部存储的非连续性，因而无法像 array 或 vector 一样使用正常的指针来充当 iterator。 list iterator12345typedef T value_type;typedef T* pointer;typedef T&amp; reference;typedef bidirectional_iterator_tag iterator_category;typedef ptrdiff_t difference_type; 上表列出了 list iterator 定义的五个 iterator_traits 所需 type；除此以外， list iterator 内部还应存在一根指向 list node 的指针： list_node&lt;T&gt;* node; list iterator 中运算符的重载为了在使用中模拟连续空间， list iterator 对与寻常指针所支持的一系列运算符进行了适应自身的重载。 operator++ `c++template list_iterator&amp; operator++(){node = node-&gt;next; return *this; }1234567- operator* - ```c++ template &lt;typename T&gt; T operator*()&#123; return node-&gt;data; &#125; list 中多余出来的节点如上图所示，呈环状的 list 中存在一个不属于 list 本身的节点，当调用list.end()时返回的 iterator 指向的便是这个节点。 在 GNUC++ 7.4 版本编译器中；经测试 list.end() == (--list.begin())，这也证实了这一现象； 不过，按理说这个不在 list 内部的节点所存放的数据、 \\prev* 和 \\next* 应该都为空，但事实上，该节点两根指针又分别指向了 list 的尾首；并且该节点的 data 是有值的，该值为 list 模板参数类型，并且会随着 list 所存储内容变化而变化，暂未发现规律…… 这一现象在 GNUC 编译器里究竟代表着什么呢？ 阅读源码，未完待续……","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/STL/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"iterator的设计原则","slug":"文章_iterator","date":"2020-04-28T09:51:45.000Z","updated":"2022-01-16T01:29:44.142Z","comments":true,"path":"2020/04/28/文章_iterator/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/04/28/%E6%96%87%E7%AB%A0_iterator/","excerpt":"在 STL 中，iterator 是容器和算法之间的桥梁，iterator 必须满足算法所需要得知的相关内容方能使容器能够正常使用算法来进行一系列操作。 iterator一般情况下，容器的iterator 必须定义如下 typedef： iterator typedef ... value_type typedef ... iterator_category typedef ... difference_type typedef ... pointer typedef ... reference 其中，各 type 表示的意义如下： value_type : iterator 所 指 元素的类型 iterator_category : iterator 的分类，用以表示当前iterator 支持何种操作 iterator_category有以下分类[信息来自cplusplus.com] : input_iterator_tag : 输入迭代器 output_iterator_tag : 输出迭代器 forward_iterator_tag : 转发迭代器 bidirectional_iterator_tag : 双向迭代器 random_access_iterator_tag : 随机访问迭代器","text":"在 STL 中，iterator 是容器和算法之间的桥梁，iterator 必须满足算法所需要得知的相关内容方能使容器能够正常使用算法来进行一系列操作。 iterator一般情况下，容器的iterator 必须定义如下 typedef： iterator typedef ... value_type typedef ... iterator_category typedef ... difference_type typedef ... pointer typedef ... reference 其中，各 type 表示的意义如下： value_type : iterator 所 指 元素的类型 iterator_category : iterator 的分类，用以表示当前iterator 支持何种操作 iterator_category有以下分类[信息来自cplusplus.com] : input_iterator_tag : 输入迭代器 output_iterator_tag : 输出迭代器 forward_iterator_tag : 转发迭代器 bidirectional_iterator_tag : 双向迭代器 random_access_iterator_tag : 随机访问迭代器 difference_type : 任意两个iterator 之间的 最大差距(注意不是距离，它包含了负值) 能够使用何种类型表示？ 一般情况下，皆使用 ptrdiff_t 来代指这一 typedef；它在编译器中被定义为 signed int 。 pointer : 指针 reference : 引用 若如此定义好相关 typedef ，算法相关函数便可以通过 iterator 获取到该算法实现所需的内容； 但由于iterator 有退化的可能性【iterator 本身是一个普通的指针而非针对该容器所适配的类，例如vector容器】，因此 STL 增加了一个中间层类用以适配iterator 的各种情形——iterator_traits iterator_traits iterator_traits 的主要实现为一个模板类，用以接受各个容器的iterator ；其中做了两个偏特化，以应对当 iterator_traits 接收到普通指针 T* 和 const T* 的状况。 在泛化的iterator_traits实现中，只是直接定义算法所需相关 type 为 iterator 的 typedef； 在偏特化的两个iterator_traits实现中有如下定义： 1234567template &lt;typename T*&gt;...typedef T value_type;typedef random_access_iterator_tag iterator_category;typedef ptrdiff_t difference_type;typedef T* pointer;typedef T&amp; reference; 1234template &lt;typename const T*&gt;...typedef const T* pointer;typedef const T&amp; reference; 上述代码需要注意的是，value_type的定义，const T*亦为 T ；这是因为在算法中，获取value_type的主要目的是为了声明变量，而声明 const 变量无任何意义。 如此，当某一容器使用算法时，算法内部便可以通过iterator_traits获取容器相关信息，用以进行相关操作; 例如： 123456789101112131415template &lt;typename corpusIter&gt; std::pair&lt;corpusIter, corpusIter&gt; operator () ( corpusIter corpus_first, corpusIter corpus_last ) const &#123; BOOST_STATIC_ASSERT (( boost::is_same&lt; typename std::iterator_traits&lt;patIter&gt;::value_type, //use value_type typename std::iterator_traits&lt;corpusIter&gt;::value_type&gt;::value ));//use value_type if ( corpus_first == corpus_last ) return std::make_pair(corpus_last, corpus_last); if (pat_first ==pat_last ) return std::make_pair(corpus_first, corpus_first); const difference_type k_corpus_length = std::distance ( corpus_first, corpus_last ); if ( k_corpus_length &lt; k_pattern_length ) return std::make_pair(corpus_last, corpus_last); return this-&gt;do_search ( corpus_first, corpus_last );&#125; 以上代码摘自 Boost 库中，算法boyer_moore的运算符重载，其中注释的两行使用了—— std::iterator_traits&lt;patIter&gt;::value_type来获取到iterator 的value_type","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/STL/"}]},{"title":"vector深度探索","slug":"文章_vector","date":"2020-04-28T06:43:26.000Z","updated":"2022-01-16T01:29:57.489Z","comments":true,"path":"2020/04/28/文章_vector/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/04/28/%E6%96%87%E7%AB%A0_vector/","excerpt":"vector 算是一种可扩充的array，用于储存它的内存与array一样，总是连续的。 一个 vector 的内部结构可能是什么样子？ vector size[int]——长度 capacity[int]——容量 data[T*]——数据项 如上所示，我们可以直接创建包含以上三个属性的vector类，其中size用以表示vector的长度，它可以是int型，capacity同理，它用来表示vector现在所有开辟出的内存空间的大小，而data自然为 指向模板参数类型的指针。 因此在以上结构下，sizeof(vector) 得出的大小为两个 int 加 一根指针，这一数值在32位电脑上为3*4=12。 vector 是如何被创建出来的以下代码以 copy constructor 函数为例，展示了一个 vector 是如何创建出来的： 1234567template &lt;typename T&gt; vector(const vector&lt;T&gt;&amp; v) :_capacity(2 * v.size()), _size(0) &#123; //将新 vector 的容量设置为原 vector 长度的两倍 _elem = new T[_capacity]; //开辟内存空间 for (auto i : v) &#123; //At C++11 _elem[_size++] = i; //将原 vector 中的元素依次赋值给新 vector &#125;&#125; vector 的动态空间管理在对 vector 进行插入操作的过程中，容器中元素的长度随时有可能超出这个容器的总容量，因此需要在此时对vector进行扩容操作。","text":"vector 算是一种可扩充的array，用于储存它的内存与array一样，总是连续的。 一个 vector 的内部结构可能是什么样子？ vector size[int]——长度 capacity[int]——容量 data[T*]——数据项 如上所示，我们可以直接创建包含以上三个属性的vector类，其中size用以表示vector的长度，它可以是int型，capacity同理，它用来表示vector现在所有开辟出的内存空间的大小，而data自然为 指向模板参数类型的指针。 因此在以上结构下，sizeof(vector) 得出的大小为两个 int 加 一根指针，这一数值在32位电脑上为3*4=12。 vector 是如何被创建出来的以下代码以 copy constructor 函数为例，展示了一个 vector 是如何创建出来的： 1234567template &lt;typename T&gt; vector(const vector&lt;T&gt;&amp; v) :_capacity(2 * v.size()), _size(0) &#123; //将新 vector 的容量设置为原 vector 长度的两倍 _elem = new T[_capacity]; //开辟内存空间 for (auto i : v) &#123; //At C++11 _elem[_size++] = i; //将原 vector 中的元素依次赋值给新 vector &#125;&#125; vector 的动态空间管理在对 vector 进行插入操作的过程中，容器中元素的长度随时有可能超出这个容器的总容量，因此需要在此时对vector进行扩容操作。 vector遵循内存空间连续的规则，但直接在vector原内存的末尾开辟空间并不现实（空间可能已被使用），因此应当直接在现有内存中新开辟出一块更大的内存空间并将原vector中的所有元素整体搬过去。 如上文代码所见，在 vector 的拷贝构造函数中，我们直接为新的 vector 分配原 vector 长度的两倍大小来储存数据，这也是目前 GNUC vector中的做法(我们将 K=2 称为vector扩容时的增长因子)： 在开辟新空间的时候，应当既要保证vector不会在短时间内再次溢出，又要保证这些空间中没有太多内存是多余的。 但是，当增长因子 K=2 时，每次扩展的新尺寸必然刚好大于之前分配的总和[例如：第一次扩容内存为1*2=2,第二次为2*2=4;那么恰好4&gt;1+(1*2)，依此类推] 这将会导致从前vector所占用的内存空间在以后vector扩容的过程中永远不会被重新使用！ 因此，最佳做法应当是将增长因子 k 设置为 1 &lt; K &lt;2 现在许多编译器已将这一因子设置为 1.5 。 123456789template &lt;typename T&gt; void vector&lt;T&gt;::expand()&#123; _capacity *= 2; //将新的容量设置为原先的2倍 T* old_elem = _elem; //创建一个临时的指针指向原先vector所存储的数据 _elem = new T[_capacity]; //开辟内存空间 for (int i = 0; i &lt; _size; ++i) &#123; _elem[i] = old_elem[i]; //将原 vector 中的元素依次赋值给新 vector &#125; delete old_elem; //删除之前所占用的内存&#125; 上述代码实例了vector的扩容操作，它应当在size==capacity时被调用。 相较vector的读取操作，扩容的时间复杂度时相当高昂的(O(n))，但在实际使用中，扩容操作随着vector规模的不断增长，调用次数也不断减少，从而可将这一操作的复杂度分摊至所有操作(O(1))。 STL 中的 vector不同编译器乃至同一编译器的不同版本对于vector的实现都是各异的，但其内在无外乎以下类结构： vector start[iterator]——指向vector容器的开始 finish[iterator]——指向vector容器的结束 end_of_storage[iterator]——指向vector所有容量的结束 如上所见， 当使用vector.begin()和vector.end()会分别直接返回start和finish迭代器； 当使用vector.size()会直接返回end()-begin(); 当使用vector.empty()会直接返回end()==begin(); …… vector 中的 iterator因vector所使用内存空间连续这一性质，vector的迭代器可直接使用 T*，原始指针已经可以满足各种对其的运算和移动操作。","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/STL/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"在城墙上看西安","slug":"相片_西安城墙","date":"2020-04-27T10:03:22.000Z","updated":"2022-01-16T01:30:22.560Z","comments":true,"path":"2020/04/27/相片_西安城墙/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/04/27/%E7%9B%B8%E7%89%87_%E8%A5%BF%E5%AE%89%E5%9F%8E%E5%A2%99/","excerpt":"","text":"","categories":[{"name":"相片","slug":"相片","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E7%9B%B8%E7%89%87/"}],"tags":[{"name":"西安","slug":"西安","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E8%A5%BF%E5%AE%89/"}]},{"title":"沉默的一万种表达方式","slug":"诗词_沉默的一万种表达方式","date":"2020-04-19T11:56:50.000Z","updated":"2022-01-16T01:25:59.053Z","comments":true,"path":"2020/04/19/诗词_沉默的一万种表达方式/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/04/19/%E8%AF%97%E8%AF%8D_%E6%B2%89%E9%BB%98%E7%9A%84%E4%B8%80%E4%B8%87%E7%A7%8D%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F/","excerpt":"","text":"红色车灯、黑色的夜 我的眼睛因此而朦胧 它看见光在人的身上穿行 看见前路漫漫、声音嘈杂 无限放大的瞳孔 盖不住世界的万分之一 沉默的一万种表达方式 我朦胧着眼，竟一言未发","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"广袤无垠的公交车","slug":"诗词_广袤无垠的公交车","date":"2020-03-26T12:14:50.000Z","updated":"2022-01-16T01:26:06.021Z","comments":true,"path":"2020/03/26/诗词_广袤无垠的公交车/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/03/26/%E8%AF%97%E8%AF%8D_%E5%B9%BF%E8%A2%A4%E6%97%A0%E5%9E%A0%E7%9A%84%E5%85%AC%E4%BA%A4%E8%BD%A6/","excerpt":"","text":"师傅在前面划 我坐在窗边看海 我们不交谈 海便一言不发 乘着广袤无垠的公交车 去航行","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"黄线以内","slug":"诗词_黄线以内","date":"2020-03-26T11:40:50.000Z","updated":"2022-01-16T01:26:12.173Z","comments":true,"path":"2020/03/26/诗词_黄线以内/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/03/26/%E8%AF%97%E8%AF%8D_%E9%BB%84%E7%BA%BF%E4%BB%A5%E5%86%85/","excerpt":"","text":"红色鞋子立起来的身躯 与未下车我的灵魂一道 在黄线以内等 前面是一头陌生长发 身后低着头 倾斜、垂直着颤栗 在线与墙壁的夹角 雨淋湿黄线以外的地方 而她不得不前行","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"白云另一边的白云","slug":"诗词_白云另一边的白云","date":"2020-03-21T12:58:50.000Z","updated":"2022-01-16T01:25:49.696Z","comments":true,"path":"2020/03/21/诗词_白云另一边的白云/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/03/21/%E8%AF%97%E8%AF%8D_%E7%99%BD%E4%BA%91%E5%8F%A6%E4%B8%80%E8%BE%B9%E7%9A%84%E7%99%BD%E4%BA%91/","excerpt":"","text":"白云另一边的白云 与它一同分割开黑夜 我和我臆想里的此刻 共同拥有一整个过去 蓝色的医用外科口罩 装饰形形色色的脸 形形色色的面目下 嚼着没有味道的口香糖","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"const见微知著","slug":"文章_const-member-fun","date":"2020-01-01T10:47:17.000Z","updated":"2022-01-16T01:31:47.112Z","comments":true,"path":"2020/01/01/文章_const-member-fun/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2020/01/01/%E6%96%87%E7%AB%A0_const-member-fun/","excerpt":"","text":"","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C/"}]},{"title":"copyConstructor&copyAssignment云开月明","slug":"文章_copyConstructor&Assignment","date":"2019-12-25T10:56:32.000Z","updated":"2022-01-16T01:28:36.573Z","comments":true,"path":"2019/12/25/文章_copyConstructor&Assignment/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2019/12/25/%E6%96%87%E7%AB%A0_copyConstructor&Assignment/","excerpt":"","text":"//TODO","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C/"}]},{"title":"C++ 面向对象之 virtual pointer 和 virtual tab","slug":"文章_vptr and vtab","date":"2019-03-23T07:30:25.000Z","updated":"2022-01-16T01:30:10.237Z","comments":true,"path":"2019/03/23/文章_vptr and vtab/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2019/03/23/%E6%96%87%E7%AB%A0_vptr%20and%20vtab/","excerpt":"在下文中： vptr == virtual pointer == (虚指针) vtab == virtual table == (虚表) Part 1: 多态 当一个类中存在虚函数时， 这个类的大小会比数据本身多一个指针的空间 。12345678910111213141516171819202122class A&#123;public: virtual void fun1()&#123;&#125; virtual void fun2()&#123;&#125; void fun3()&#123;&#125; void fun4()&#123;&#125;private: int a,b,c;&#125;;class B : public A&#123;public: virtual void fun1()&#123;&#125; void bFun()&#123;&#125;&#125;;class C&#123;public: void cFun1()&#123;&#125; void cFun2()&#123;&#125; void cFun3()&#123;&#125;private: int a,b,c;&#125;;","text":"在下文中： vptr == virtual pointer == (虚指针) vtab == virtual table == (虚表) Part 1: 多态 当一个类中存在虚函数时， 这个类的大小会比数据本身多一个指针的空间 。12345678910111213141516171819202122class A&#123;public: virtual void fun1()&#123;&#125; virtual void fun2()&#123;&#125; void fun3()&#123;&#125; void fun4()&#123;&#125;private: int a,b,c;&#125;;class B : public A&#123;public: virtual void fun1()&#123;&#125; void bFun()&#123;&#125;&#125;;class C&#123;public: void cFun1()&#123;&#125; void cFun2()&#123;&#125; void cFun3()&#123;&#125;private: int a,b,c;&#125;;如上图所示，在 class A 中，存在两个虚函数 。 子类 class B 重写了虚函数 fun1() ，同时拥有一个自身的成员函数 bFun() 。 这两个个类同时拥有 class A 中的 —— 三个 int 类型的成员。 而 class C 独立存在，并且拥有 三个非虚成员函数 ，同样拥有三个 int 类型的成员。123456int main() &#123; std::cout &lt;&lt; sizeof(A) &lt;&lt; std::endl; std::cout &lt;&lt; sizeof(B) &lt;&lt; std::endl; std::cout &lt;&lt; sizeof(C) &lt;&lt; std::endl; return 0;&#125;众所周知，在 32 位系统中，一个 int 类型的数据占据四个字节。当我们 sizeof() 这三个类时，应当得到三个 int 的大小也就是 12 个字节数。 但由于虚函数的存在， class A 与 class B 应当多出一个指针大小，亦为四字节。 如图所示， class A 的子类 class B 继承了虚函数以及一个指针大小内存。 而在没有任何虚函数的 class C 中，所占内存只有成员大小。 并且， 无论存在多少个虚函数，所占用的内存始终为一个指针大小 。 Part 2: 在含有虚函数的类中多出来的虚指针指向的位置 虚指针指向一张记载有虚函数地址的表 ，这张记载有虚函数位置的表称为 virtual table (虚表)。 virtual table 中的每一个函数指针都指向一个虚函数，也就是说 virtual table 中的函数指针个数等同于该类中的虚函数的个数。 继承的类和父类分别拥有各自的 virtual table ，这些 virtual table 指向他们各自所需要调用的虚函数的位置，因而当分别使用某一个类的对象来调用虚函数的时候，会自动寻找到适当的函数进而调用。 Part 3: 动态绑定 如上图所示，假设有一根指向 class B 对象的指针 P ，当程序需要调用 p 所指对象的虚函数 fun1() 时，会执行如下步骤。 通过指针 P 找到 class B 的 vptr 通过 vptr 找到 vtab 在 vtab 中，找到所需虚函数的位置 调用该函数 我们把这种通过 vptr , vtab 的绑定方式称为 动态绑定 。 而若将这一步骤转换为静态绑定的调用方式则为如下所示： ( (p-&gt;vtab[n]) )(p)* 其中， n 便是所需函数位于 virtual table 中的位置。 同样的，当一个 class B 的对象 b 调用 fun1() 时，底层的操作为： b.fun1(); ( (this-&gt;vtab[n] ) (this))* 反观静态绑定，只能通过早先汇编语言中 call 的方式根据特定的地址来调用各自的函数。 本文验证所用编译器为 Visual Studio 2019编译和运行环境为 windows x86","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C/"}]},{"title":"C++11 之 Variadic Templates(数量不定的模板参数)","slug":"文章_Abort variadic templates","date":"2019-03-20T10:05:50.000Z","updated":"2022-01-16T01:29:11.683Z","comments":true,"path":"2019/03/20/文章_Abort variadic templates/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2019/03/20/%E6%96%87%E7%AB%A0_Abort%20variadic%20templates/","excerpt":"“ . . . “ 在 C++11 中，引入了新的特性，允许在模板参数中使用数量不确定的参数。 当然，这个函数需要 至少有一个固定参数。 例如：12345template &lt;typename T, typename... Types&gt;void autoPrint(const T&amp; a, const Type&amp;... args)&#123; cout &lt;&lt; a &lt;&lt; endl; autoPrint(args...);&#125; 如以上程序所示，在函数模板中， Types 代表着暂不确定数量的参数。 因此，当使用者调用起 autoPrint 函数时，如果参数大于一个，在执行完函数内容以后，会递归调用自身，直到 没有参数 为止。 例如：123456autoPrint(1,&quot;hello&quot;,2.37,ture);//以下为输出：1hello2.37ture","text":"“ . . . “ 在 C++11 中，引入了新的特性，允许在模板参数中使用数量不确定的参数。 当然，这个函数需要 至少有一个固定参数。 例如：12345template &lt;typename T, typename... Types&gt;void autoPrint(const T&amp; a, const Type&amp;... args)&#123; cout &lt;&lt; a &lt;&lt; endl; autoPrint(args...);&#125; 如以上程序所示，在函数模板中， Types 代表着暂不确定数量的参数。 因此，当使用者调用起 autoPrint 函数时，如果参数大于一个，在执行完函数内容以后，会递归调用自身，直到 没有参数 为止。 例如：123456autoPrint(1,&quot;hello&quot;,2.37,ture);//以下为输出：1hello2.37ture 需要注意的是，因为会递归调用，而函数本身没有出口。当递归到 没有参数 的时候，无法再次调用自身。 因而在构建这样的函数模板时 必须重载一个与本函数重载且无参的函数 所以，上面的写法，在编译过程中无法通过，因为当递归到 args… 没有参数的时候，程序无法继续进行。123void autoPrint()&#123;&#125;只有与如上的无参函数 同时存在 ，程序才会正常执行。 1sizeof...(args) 如果想要得知那些 不定参数 具体有多少个的时候，就需要使用 sizeof…() 来获得。 当然，在函数中不必非要递归调用自己，亦可进行想要的操作。譬如进行组合继承等更加复杂的操作。","categories":[{"name":"文章","slug":"文章","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C/"},{"name":"泛型编程","slug":"泛型编程","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"},{"name":"C++11","slug":"C-11","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/C-11/"}]},{"title":"西江月","slug":"诗词_西江月","date":"2018-11-17T17:11:23.000Z","updated":"2022-01-16T01:27:47.085Z","comments":true,"path":"2018/11/18/诗词_西江月/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2018/11/18/%E8%AF%97%E8%AF%8D_%E8%A5%BF%E6%B1%9F%E6%9C%88/","excerpt":"","text":"迟来晓雨无端，恨不任随秋去。 旧愁借我无归期，飞尽落花几许? 醉眼高看楼台，东城锦书难寄。 年少夜寒泪依依，风起吹罢别离。","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"词","slug":"词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E8%AF%8D/"}]},{"title":"我耳旁古都的风也疾驰","slug":"诗词_我耳旁古都的风也疾驰","date":"2018-09-17T19:05:50.000Z","updated":"2022-01-16T01:27:48.577Z","comments":true,"path":"2018/09/18/诗词_我耳旁古都的风也疾驰/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2018/09/18/%E8%AF%97%E8%AF%8D_%E6%88%91%E8%80%B3%E6%97%81%E5%8F%A4%E9%83%BD%E7%9A%84%E9%A3%8E%E4%B9%9F%E7%96%BE%E9%A9%B0/","excerpt":"","text":"我耳旁古都的风也疾驰 看见树在落叶 人在往返 从前旧的巷道里 有白蝴蝶飞过的气味 有风筝和嘈杂的光 可熙攘碰撞我的身躯 是在追逐你的影子 还是追逐谁的孤独 不是我的孤独 At XI`AN 写于西安","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"诗人漫步在陌生的黑夜里","slug":"诗词_诗人漫步在陌生的黑夜里","date":"2018-03-20T10:05:50.000Z","updated":"2022-01-16T01:26:38.566Z","comments":true,"path":"2018/03/20/诗词_诗人漫步在陌生的黑夜里/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2018/03/20/%E8%AF%97%E8%AF%8D_%E8%AF%97%E4%BA%BA%E6%BC%AB%E6%AD%A5%E5%9C%A8%E9%99%8C%E7%94%9F%E7%9A%84%E9%BB%91%E5%A4%9C%E9%87%8C/","excerpt":"","text":"诗人漫步在陌生的黑夜里 凝望着触不可及没有星的空 他想写这黑夜 却不知如何写你 月光中悠悠而过的别处微风 以为轻拂着你的面颊 倒映在无人的窗棂上 又徘徊，又飞舞 风在风里摇曳 我在哪里飘零","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"无题","slug":"诗词_无题","date":"2018-03-20T08:25:50.000Z","updated":"2022-01-16T01:27:47.684Z","comments":true,"path":"2018/03/20/诗词_无题/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2018/03/20/%E8%AF%97%E8%AF%8D_%E6%97%A0%E9%A2%98/","excerpt":"","text":"寂寞五更无梦夜 人倚楼台，风雨正飘摇。 相似欲把春愁借。 画船东访，憔悴自西流。","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"词","slug":"词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E8%AF%8D/"}]},{"title":"如梦令","slug":"诗词_如梦令","date":"2018-02-25T19:25:50.000Z","updated":"2022-01-16T01:26:22.218Z","comments":true,"path":"2018/02/26/诗词_如梦令/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2018/02/26/%E8%AF%97%E8%AF%8D_%E5%A6%82%E6%A2%A6%E4%BB%A4/","excerpt":"","text":"经年不返愁别，轻语诉梦思灭。 雪散漫漫舞，飞上眉梢花谢。 孤夜。孤夜。 才登佳人楼阙。","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"词","slug":"词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E8%AF%8D/"}]},{"title":"水龙吟","slug":"诗词_水龙吟","date":"2018-02-20T12:03:00.000Z","updated":"2022-01-16T01:31:45.661Z","comments":true,"path":"2018/02/20/诗词_水龙吟/","link":"","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/2018/02/20/%E8%AF%97%E8%AF%8D_%E6%B0%B4%E9%BE%99%E5%90%9F/","excerpt":"","text":"沐风又淋暮雨，偏照灿灿晚来灯。 流水去处，顺载黄叶，一洗陈思。 高楼过眼，遮天遥望，还遇高楼。 青天浴归人，半遮湿眉，却露眼、泪三分。 不悲初春细雨，悲旧堂，未语新言。 镜花已碎，水月何寻? 车马逐路，易追年岁，难追离人。 书词罢，暮雨将息，初觉寒风渐渐。","categories":[{"name":"诗词","slug":"诗词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"词","slug":"词","permalink":"https://github.com/leftumbrella/leftumbrella.github.io/tree/blog/tags/%E8%AF%8D/"}]}]